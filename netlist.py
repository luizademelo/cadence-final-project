# (C) 2024 Cadence Design Systems, Inc. All rights reserved worldwide.

"""
Python module for manipulating JSON netlists generated by YosysHQ.

Compile RTL source files with YosysHQ and generate a JSON netlist dump to use
the utilities in this module.

Contents:
    . class Net:        Object representing netlist Nets (wires in the circuit)

    . class Gate:       Object representing netlist Gates (logic circuit
                        connections)

    . class Netlist:    A Netlist graph representation

    . class RTL:        A collection of all netlists inside an RTL source file.
                        Constructed from parsing YosysHQ's JSON netlist format:
                        e.g.: 'netlist.RTL(json.load(file))'.

                        NOTE: If the RTL file is compiled on YosysHQ with the
                        'flatten' command, all the file contents are flattened
                        into a single Netlist.

    . class Visitor:    Abstract class used for implementing traversals on a
                        Netlist
"""

from abc import ABC, abstractmethod
from enum import Enum

def dict_get(dictionary : dict, key : any, default : any):
    """
    Utility for safely getting item from dictionary. Returns 'default' if not
    found
    """
    try:
        return dictionary[key]
    except KeyError:
        return default

class Node:
    """
    Node is a base class representing a node in the Netlist graph

    Members:
        . name : str
        . hidden : bool             True if this node represents hidden netlist
                                    logic. All names declared in the RTL source
                                    code are not hidden.
        . inputs : list of Node
        . outputs : list of Node
    """
    def __init__(self, name : str, hidden : bool):
        self.name = name
        self.hidden = hidden
        self.inputs = list()
        self.outputs = list()

    def add_input(self, input : any):
        self.inputs.append(input)

    def add_output(self, output : any):
        self.outputs.append(output)

    def __repr__(self):
        return "{{inputs: {} outputs: {}}}".format(self.inputs, self.outputs)

class Net(Node):
    """
    Net is a node in the Netlist graph.
    Nets represent individual bits from the RTL Netlist.

    Members:
        . bit : int                 Unique numerical identifier for this bit
                                    in the Netlist
        . aliases : list of str     Alternative names used for this Net in the
                                    Netlist. Method 'Netlist.find_net' may
                                    match either the Net name or any of the
                                    aliases
    """
    def __init__(self, name : str, bit : int, hidden : bool):
        super().__init__(name, hidden)
        self.bit = bit
        self.aliases = list()

    def __repr__(self):
        return "{{{}: {}}}\n".format(self.bit, self.name)

    def add_alias(self, name : str):
        self.aliases.append(name)

class Gate(Node):
    """
    Gate is a node in the Netlist graph. It connects two or more Nets

    Methods:
        . get_clock() -> list of Net
                                    Returns a list with the clock net of this
                                    gate, if it is a flip-flop

    Members:
        . type : str                String identifier of the cell type
                                    implemented by this gate. Indicates its
                                    logical function (e.g. $add, $and, $not)
    """
    def __init__(self, name : str, type : str, hidden : bool):
        super().__init__(name, hidden)
        self.type = type

    def __repr__(self):
        return "{{{}: {}}}\n".format(self.name, self.type)

    def get_clock(self):
        if self.type == "$dff":
            # The clock pin is always the last input in the $dff gate
            return [self.inputs[-1]]

        return list()

class Netlist:
    """
    Netlist is a graph representation of a SystemVerilog module

    Methods:
        . find_net(name : str) -> Net | None
                                    Returns the net with name or alias "name",
                                    or None if not found
        . find_bit(bit : int) -> Net | None
                                    Returns the net identified by the given
                                    bit number, or None if not found

    Members:
        . name : str                Name of the SV module originating this
                                    Netlist
        . nets : dict of int, Net   Dictionary mapping unique bit identifiers
                                    to Nets
        . gates : list of Gate
    """
    def __init__(self, name : str, json_module : dict):
        self.name = name
        self.nets = dict()
        self.gates = list()

        self._init_nets(json_module)
        self._init_gates(json_module)

    def find_net(self, name : str):
        """
        Find Net by name in the netlist.
        """
        for _, net in self.nets.items():
            if net.name == name:
                return net
            for alias in net.aliases:
                if alias == name:
                    return net
        return None

    def find_bit(self, bit : int):
        """
        Find Net by bit identifier in the netlist.
        """
        return dict_get(self.nets, bit, None)

    def _init_nets(self, json_module : dict):
        nets = dict_get(json_module, "netnames", dict())
        for name, net in nets.items():
            bits = dict_get(net, "bits", list())
            hidden = bool(dict_get(net, "hide_name", 0))
            size = len(bits)
            for i, bit in enumerate(bits):
                bitname = "{}[{}]".format(name, size - i - 1)
                if not bit in self.nets:
                    self.nets[bit] = Net(bitname, bit, hidden)
                else:
                    self.nets[bit].add_alias(bitname)

    def _init_gates(self, json_module : dict):
        gates = dict_get(json_module, "cells", list())
        for name, gate in gates.items():
            type = dict_get(gate, "type", str())
            hidden = bool(dict_get(gate, "hide_name", 0))
            inputs, outputs = self._get_connections(gate)

            gate = Gate(name, type, hidden)
            self.gates.append(gate)

            self._connect_nets(gate, inputs, outputs)

    def _get_connections(self, json_gate : dict):
        directions = dict_get(json_gate, "port_directions", dict())
        connections = dict_get(json_gate, "connections", dict())

        inputs = list()
        outputs = list()

        for connection, bits in connections.items():
            direction = dict_get(directions, connection, str())
            if direction == "input":
                inputs.extend(bits)
            elif direction == "output":
                outputs.extend(bits)
            elif direction == "inout":
                inputs.extend(bits)
                outputs.extend(bits)

        return inputs, outputs

    def _connect_nets(self, gate : Gate, inputs : list, outputs : list):
        for bit in inputs:
            net = dict_get(self.nets, bit, None)
            if net:
                net.add_output(gate)
                gate.add_input(net)
        for bit in outputs:
            net = dict_get(self.nets, bit, None)
            if net:
                net.add_input(gate)
                gate.add_output(net)

    def __repr__(self):
        return "{{nets: {},\ngates: {}}}".format(self.nets, self.gates)

class RTL:
    """
    RTL is a collection of Netlists
    """
    def __init__(self, json_nl : dict):
        self.netlists = list()

        modules = dict_get(json_nl, "modules", dict())

        for name, module in modules.items():
            self.netlists.append(Netlist(name, module))

    def __repr__(self):
        return self.netlists.__repr__()

class Direction(Enum):
    FORWARD = 0
    BACKWARD = 1
    BIDIRECTIONAL = 2

class Algorithm(Enum):
    BFS = 0
    DFS = 1

class Visitor(ABC):
    """
    Visitor runs a traversal on the Netlist graph
    """
    def __init__(self, netlist : Netlist, direction : Direction,
                 algorithm : Algorithm):
        self.netlist = netlist
        self.direction = direction
        self.algorithm = algorithm

    def traverse(self, start : Net):
        """
        Run a traversal starting from the 'start' Net. Traversal direction and
        algorithm are set in the Visitor constructor.
        """
        traversal_list = [start]

        while traversal_list:
            if self.algorithm == Algorithm.BFS:
                node = traversal_list[0]
                traversal_list.pop(0)
            elif self.algorithm == Algorithm.DFS:
                node = traversal_list[-1]
                traversal_list.pop()

            if type(node) == Net:
                if not self.visit(node):
                    continue
                else:
                    next_nodes = self.get_next_nodes(node)
                    traversal_list.extend(next_nodes)
            elif type(node) == Gate:
                next_nodes = self.visit_gate(node)
                traversal_list.extend(next_nodes)

    def get_next_nodes(self, node):
        if self.direction == Direction.FORWARD:
            return node.outputs
        elif self.direction == Direction.BACKWARD:
            return node.inputs
        elif self.direction == Direction.BIDIRECTIONAL:
            return node.inputs + node.outputs

    @abstractmethod
    def visit(self, net : Net) -> bool:
        """
        Called when the visitor passes by a Net. Return 'True' if traversal
        must continue after this net, or 'False' to stop traversing this node.
        """
        pass

    @abstractmethod
    def visit_gate(self, gate : Gate) -> list:
        """
        Called when the visitor passes by a Gate. Return a list of Nets that
        will be the next visited nodes according to the Visitor algorithm.
        """
        pass
